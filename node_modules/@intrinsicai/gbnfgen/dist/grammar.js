export function isSequence(rule) {
    return rule.type === "sequence";
}
export function isGroup(rule) {
    return rule.type === "group";
}
export function isLiteral(rule) {
    return rule.type === "literal";
}
export function isReference(rule) {
    return rule.type === "reference";
}
export function isCharRange(rule) {
    return rule.type === "char-range";
}
function serializeRule(rule) {
    if (isSequence(rule)) {
        return serializeSequence(rule);
    }
    else if (isGroup(rule)) {
        return serializeGroup(rule);
    }
    else if (isLiteral(rule)) {
        return serializeLiteralRule(rule);
    }
    else if (isReference(rule)) {
        return serializeReference(rule);
    }
    else if (isCharRange(rule)) {
        return serializeCharRange(rule);
    }
    throw new Error(`Unknown rule ${rule}`);
}
function serializeSequence(rule) {
    return rule.rules.map(serializeRule).join("   ");
}
function serializeGroup(rule) {
    const multiplicity = {
        none: "",
        optional: "?",
        star: "*",
        plus: "+",
    }[rule.multiplicity];
    return `(${serializeSequence(rule.rules)})${multiplicity}`;
}
function serializeLiteralRule(rule) {
    return JSON.stringify(rule.literal);
}
function serializeReference(rule) {
    return rule.referee;
}
function serializeCharRange(rule) {
    return rule.pattern.source;
}
export function serializeElement(grammarElement, declaredTypes) {
    if (!grammarElement.identifier.match(`^[a-zA-Z]+$`)) {
        throw new Error(`Rule name ${grammarElement.identifier} must match pattern [a-zA-Z] and cannot contain special characters`);
    }
    const invalidReferences = new Set(grammarElement.alternatives
        .filter(isReference)
        .map((referenceRule) => referenceRule.referee)
        .filter((ref) => !declaredTypes.has(ref)));
    if (invalidReferences.size > 0) {
        throw new Error(`Invalid references in ruleset: ${invalidReferences}`);
    }
    const rules = grammarElement.alternatives.map(serializeRule).join(` | `);
    return `${grammarElement.identifier} ::= ${rules}`;
}
export function serializeGrammar(grammar) {
    let out = "";
    const declaredTypes = new Set(grammar.elements.map((elem) => elem.identifier));
    grammar.elements.forEach((element) => {
        out += serializeElement(element, declaredTypes);
        out += "\n";
    });
    return out;
}
export function literal(value) {
    return {
        type: "literal",
        literal: value,
    };
}
export function charPattern(pattern) {
    return {
        type: "char-range",
        pattern,
    };
}
export function sequence(...values) {
    return {
        type: "sequence",
        rules: values,
    };
}
export function reference(value) {
    return {
        type: "reference",
        referee: value,
    };
}
export function group(rules, multiplicity) {
    return {
        type: "group",
        rules,
        multiplicity,
    };
}
